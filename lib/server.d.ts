import { BlockResult, Data, FilterOptions, LogObject, ProofResult, Quantity, Service, Tag, TransactionForCall, TransactionForSend, TransactionReceipt, TransactionResult, TypedData } from './service.js';
import { Engine } from '@aurora-is-near/engine';
interface NearProvider {
    networkId: string;
    evm_contract: string;
    isReadOnly: boolean;
    url: string;
    version: string;
    nearProvider: any;
    keyStore: any;
    signer: any;
    connection: any;
    accountId: string;
    account: any;
    accountEvmAddress: string;
    accounts: Map<string, any>;
    walletUrl: string;
    explorerUrl: string;
}
interface ServerOptions {
    dummy: string;
}
export declare class Server implements Service {
    readonly sql: any;
    readonly engine: Engine;
    readonly provider: NearProvider;
    readonly options: ServerOptions;
    constructor(sql: any, engine: Engine, provider: NearProvider, options: ServerOptions);
    web3_clientVersion(): Promise<string>;
    web3_sha3(input: Data): Promise<Data>;
    net_listening(): Promise<boolean>;
    net_peerCount(): Promise<Quantity>;
    net_version(): Promise<string>;
    eth_accounts(): Promise<Data[]>;
    eth_blockNumber(): Promise<Quantity>;
    eth_call(transaction: TransactionForCall, blockNumber?: Quantity | Tag): Promise<Data>;
    eth_chainId(): Promise<Quantity>;
    eth_coinbase(): Promise<Data>;
    eth_compileLLL(_code: string): Promise<Data>;
    eth_compileSerpent(_code: string): Promise<Data>;
    eth_compileSolidity(_code: string): Promise<Data>;
    eth_estimateGas(_transaction: TransactionForCall, _blockNumber?: Quantity | Tag): Promise<Quantity>;
    eth_gasPrice(): Promise<Quantity>;
    eth_getBalance(address: Data, blockNumber?: Quantity | Tag): Promise<Quantity>;
    eth_getBlockByHash(blockHash: Data, fullObject?: boolean): Promise<BlockResult | null>;
    eth_getBlockByNumber(blockNumber: Quantity | Tag, fullObject?: boolean): Promise<BlockResult | null>;
    eth_getBlockTransactionCountByHash(blockHash: Data): Promise<Quantity | null>;
    eth_getBlockTransactionCountByNumber(blockNumber: Quantity | Tag): Promise<Quantity | null>;
    eth_getCode(address: Data, _blockNumber: Quantity | Tag): Promise<Data>;
    eth_getCompilers(): Promise<string[]>;
    eth_getFilterChanges(filterID: Quantity): Promise<LogObject[]>;
    eth_getFilterLogs(filterID: Quantity): Promise<LogObject[]>;
    eth_getLogs(_filter: FilterOptions): Promise<LogObject[]>;
    eth_getProof(_address: Data, _keys: Data[], _blockNumber: Quantity | Tag): Promise<ProofResult>;
    eth_getStorageAt(address: Data, key: Quantity, blockNumber: Quantity | Tag): Promise<Data>;
    eth_getTransactionByBlockHashAndIndex(blockHash: Data, transactionIndex: Quantity): Promise<TransactionResult | null>;
    eth_getTransactionByBlockNumberAndIndex(blockNumber: Quantity | Tag, transactionIndex: Quantity): Promise<TransactionResult | null>;
    eth_getTransactionByHash(transactionHash: Data): Promise<TransactionResult | null>;
    eth_getTransactionCount(address: Data, _blockNumber: Quantity | Tag): Promise<Quantity>;
    eth_getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt | null>;
    eth_getUncleByBlockHashAndIndex(_blockHash: Data, _uncleIndex: Quantity): Promise<BlockResult | null>;
    eth_getUncleByBlockNumberAndIndex(_blockNumber: Quantity | Tag, _uncleIndex: Quantity): Promise<BlockResult | null>;
    eth_getUncleCountByBlockHash(blockHash: Data): Promise<Quantity | null>;
    eth_getUncleCountByBlockNumber(blockNumber: Quantity | Tag): Promise<Quantity | null>;
    eth_getWork(): Promise<Data[]>;
    eth_hashrate(): Promise<Quantity>;
    eth_mining(): Promise<false>;
    eth_newBlockFilter(): Promise<Quantity>;
    eth_newFilter(_filter: FilterOptions): Promise<Quantity>;
    eth_newPendingTransactionFilter(): Promise<Quantity>;
    eth_pendingTransactions(): Promise<Record<string, string | number | null>[]>;
    eth_protocolVersion(): Promise<string>;
    eth_sendRawTransaction(transaction: Data): Promise<Data>;
    eth_sendTransaction(transaction: TransactionForSend): Promise<Data>;
    eth_sign(_account: Data, _message: Data): Promise<Data>;
    eth_signTransaction(_transaction: TransactionForSend): Promise<Data>;
    eth_signTypedData(_address: Data, _data: TypedData): Promise<Data>;
    eth_submitHashrate(_hashrate: Quantity, _clientID: Quantity): Promise<false>;
    eth_submitWork(_nonce: Data, _powHash: Data, _mixDigest: Data): Promise<false>;
    eth_syncing(): Promise<false>;
    eth_uninstallFilter(filterID: Quantity): Promise<boolean>;
}
export {};
